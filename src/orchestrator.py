# -*- coding: utf-8 -*-
"""
orchestrator.py - RALPH Main Orchestrator Engine
Connects UI (setup_window.py) with agents (deepseek_client, agent_coordinator)

Handles:
- Project creation & management
- Workspace initialization
- Agent coordination
- Multi-agent execution
"""

from dataclasses import dataclass, asdict
from enum import Enum
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, List, Any
import json
import logging
import sys
from abc import ABC, abstractmethod

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('ralph.log', encoding='utf-8'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger("Orchestrator")


# ============================================================================
# DATA MODELS
# ============================================================================

class ProjectDomain(str, Enum):
    """Supported project domains"""
    LLM_APP = "llm-app"
    WEB_APP = "web_app"
    BACKEND_API = "backend_api"
    MICROSERVICES = "microservices"
    DATA_PIPELINE = "data_pipeline"
    AUTOMATION = "automation"
    CLI_TOOL = "cli_tool"
    ML_MODEL = "ml_model"
    OTHER = "other"


class ArchitectureType(str, Enum):
    """Supported architecture patterns"""
    CLEAN = "clean_architecture"
    MVC = "mvc"
    LAYERED = "layered"
    MICROSERVICES = "microservices"
    HEXAGONAL = "hexagonal"
    MODULAR_MONOLITH = "modular_monolith"
    DDD = "domain_driven_design"


@dataclass
class ProjectConfig:
    """Project configuration - sent from UI"""
    name: str
    domain: str
    description: str = ""
    architecture: str = "clean_architecture"
    framework: str = "FastAPI"
    language: str = "Python"
    database: str = "PostgreSQL"
    duration_hours: int = 4
    target_lines_of_code: int = 5000
    testing_coverage: int = 85
    parallel_agents: int = 4
    deployment_target: str = "Docker"
    timestamp: str = ""

    def __post_init__(self):
        if not self.timestamp:
            self.timestamp = datetime.now().isoformat()

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

    @classmethod
    def from_dict(cls, data: Dict) -> "ProjectConfig":
        return cls(**data)


# ============================================================================
# WORKSPACE MANAGER
# ============================================================================

class WorkspaceManager:
    """Manages project workspace initialization"""

    def __init__(self, workspace_root: Path):
        self.workspace_root = workspace_root
        self.workspace_root.mkdir(parents=True, exist_ok=True)

    def create_project_workspace(self, project_id: str, config: ProjectConfig) -> Path:
        """Create project workspace structure"""
        project_dir = self.workspace_root / "projects" / project_id
        project_dir.mkdir(parents=True, exist_ok=True)

        # Create subdirectories
        directories = [
            project_dir / "workspace" / "config",
            project_dir / "workspace" / "input",
            project_dir / "workspace" / "output" / "generated_code",
            project_dir / "workspace" / "output" / "architectures",
            project_dir / "workspace" / "output" / "logs",
            project_dir / "src",
        ]

        for dir_path in directories:
            dir_path.mkdir(parents=True, exist_ok=True)

        logger.info(f"ðŸ“ Created workspace structure for {project_id}")
        return project_dir

    @staticmethod
    def create_config_files(project_dir: Path, config: ProjectConfig):
        """Create initial config files"""
        # Save config.json
        config_file = project_dir / "config.json"
        with open(config_file, 'w', encoding='utf-8') as f:
            json.dump(config.to_dict(), f, indent=2)

        # Create README.md
        readme_content = f"""# {config.name}

## Project Information
- **Domain**: {config.domain}
- **Architecture**: {config.architecture}
- **Framework**: {config.framework}
- **Language**: {config.language}
- **Database**: {config.database}
- **Created**: {config.timestamp}

## Quick Start
```bash
cd {project_dir.name}
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt
```

## Project Structure
```
workspace/
â”œâ”€â”€ config/              # Configuration files
â”œâ”€â”€ input/               # Input data
â””â”€â”€ output/              # Generated output
    â”œâ”€â”€ generated_code/  # AI-generated code
    â”œâ”€â”€ architectures/   # Architecture blueprints
    â””â”€â”€ logs/            # Execution logs

src/                     # Your source code
```

## Architecture
Generated by RALPH - Multi-Agent Development System
"""
        (project_dir / "README.md").write_text(readme_content)

        # Create requirements.txt
        base_deps = [
            "python-dotenv>=0.19.0",
            "pydantic>=1.8.0",
            "loguru>=0.5.3",
            "aiohttp>=3.8.0",
        ]

        framework_deps = {
            "FastAPI": ["fastapi>=0.68.0", "uvicorn>=0.15.0"],
            "Django": ["django>=3.2", "djangorestframework>=3.12.0"],
            "Flask": ["flask>=2.0.0"],
        }

        db_deps = {
            "PostgreSQL": ["psycopg2-binary>=2.9.0", "sqlalchemy>=1.4.0"],
            "MongoDB": ["pymongo>=3.12.0"],
            "SQLite": ["sqlalchemy>=1.4.0"],
            "Redis": ["redis>=3.5.3"],
        }

        all_deps = (
            base_deps +
            framework_deps.get(config.framework, []) +
            db_deps.get(config.database, []) +
            ["pytest>=6.2.0", "black>=21.0", "flake8>=3.9.0"]
        )

        req_file = project_dir / "requirements.txt"
        req_file.write_text("\n".join(sorted(set(all_deps))))

        logger.info(f"ðŸ“ Created config files")


# ============================================================================
# ORCHESTRATOR - MAIN ENGINE
# ============================================================================

class RalphOrchestrator:
    """
    Main orchestrator engine.
    Manages project lifecycle and coordinates all components.
    """

    def __init__(self, workspace_dir: Optional[Path] = None):
        """Initialize orchestrator"""
        self.workspace = workspace_dir or Path.home() / ".ralph"
        self.workspace.mkdir(parents=True, exist_ok=True)

        self.workspace_manager = WorkspaceManager(self.workspace)
        self.current_config: Optional[ProjectConfig] = None
        self.current_project_dir: Optional[Path] = None
        self.execution_log: List[str] = []

        logger.info("ðŸš€ RALPH Orchestrator initialized")
        logger.info(f"   Workspace: {self.workspace}")

    def create_project(self, config: ProjectConfig) -> Dict[str, Any]:
        """
        Create new project.
        Called by UI after user fills in project details.
        """
        try:
            self.current_config = config

            # Generate project ID
            project_id = self._generate_project_id(config.name)

            # Create workspace
            project_dir = self.workspace_manager.create_project_workspace(
                project_id, config
            )
            self.current_project_dir = project_dir

            # Create config files
            WorkspaceManager.create_config_files(project_dir, config)

            # Log event
            self.execution_log.append(
                f"âœ… Project created: {project_id}"
            )

            logger.info(f"âœ… Project created successfully: {project_id}")

            return {
                "status": "success",
                "project_id": project_id,
                "project_name": config.name,
                "path": str(project_dir),
                "workspace": str(project_dir / "workspace"),
                "config": config.to_dict(),
                "created_at": datetime.now().isoformat(),
            }

        except Exception as e:
            error_msg = f"Failed to create project: {str(e)}"
            self.execution_log.append(f"âŒ {error_msg}")
            logger.error(error_msg, exc_info=True)
            return {
                "status": "error",
                "error": error_msg,
            }

    def _generate_project_id(self, name: str) -> str:
        """Generate unique project ID"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        safe_name = name.lower().replace(" ", "_").replace("-", "_")
        return f"ralph_{safe_name}_{timestamp}"

    def list_projects(self) -> List[Dict[str, Any]]:
        """
        List all projects in workspace.
        Called by UI to refresh projects list.
        """
        projects = []
        projects_dir = self.workspace / "projects"

        if not projects_dir.exists():
            return projects

        try:
            for project_dir in sorted(projects_dir.iterdir()):
                if project_dir.is_dir():
                    config_file = project_dir / "config.json"
                    if config_file.exists():
                        try:
                            with open(config_file, 'r', encoding='utf-8') as f:
                                config_data = json.load(f)

                            projects.append({
                                "project_id": project_dir.name,
                                "name": config_data.get("name", "Unknown"),
                                "domain": config_data.get("domain", ""),
                                "architecture": config_data.get("architecture", ""),
                                "path": str(project_dir),
                                "created_at": config_data.get("timestamp", ""),
                                "status": "ready",
                            })
                        except json.JSONDecodeError:
                            logger.warning(f"Invalid config.json in {project_dir.name}")
        except Exception as e:
            logger.error(f"Error listing projects: {e}")

        logger.info(f"ðŸ“Š Found {len(projects)} projects")
        return projects

    def get_project(self, project_id: str) -> Optional[Dict[str, Any]]:
        """Get specific project details"""
        project_dir = self.workspace / "projects" / project_id
        config_file = project_dir / "config.json"

        if not config_file.exists():
            return None

        try:
            with open(config_file, 'r', encoding='utf-8') as f:
                config_data = json.load(f)

            return {
                "project_id": project_id,
                "config": config_data,
                "path": str(project_dir),
                "workspace": str(project_dir / "workspace"),
            }
        except Exception as e:
            logger.error(f"Error reading project {project_id}: {e}")
            return None

    def get_execution_log(self) -> List[str]:
        """Get execution log for UI display"""
        return self.execution_log

    def clear_execution_log(self):
        """Clear execution log"""
        self.execution_log = []

    def add_log_message(self, message: str):
        """Add message to execution log"""
        self.execution_log.append(message)
        logger.info(message)

    async def generate_architecture_blueprint(self) -> Dict[str, Any]:
        """
        Generate architecture blueprint.
        Would integrate with deepseek_client and agent_coordinator here.
        """
        if not self.current_config or not self.current_project_dir:
            return {"status": "error", "error": "No project loaded"}

        try:
            self.add_log_message("ðŸ—ï¸ Generating architecture blueprint...")

            blueprint = {
                "architecture": self.current_config.architecture,
                "framework": self.current_config.framework,
                "language": self.current_config.language,
                "database": self.current_config.database,
                "modules": self._get_architecture_modules(),
                "generated_at": datetime.now().isoformat(),
            }

            blueprint_file = (
                self.current_project_dir / "workspace" / "output" /
                "architectures" / "blueprint.json"
            )
            with open(blueprint_file, 'w', encoding='utf-8') as f:
                json.dump(blueprint, f, indent=2)

            self.add_log_message(f"âœ… Blueprint saved: {blueprint_file}")

            return {
                "status": "success",
                "blueprint": blueprint,
                "saved_at": str(blueprint_file),
            }
        except Exception as e:
            error_msg = f"Architecture generation failed: {str(e)}"
            self.add_log_message(f"âŒ {error_msg}")
            return {"status": "error", "error": error_msg}

    def _get_architecture_modules(self) -> List[str]:
        """Get modules for selected architecture"""
        architectures = {
            "clean_architecture": [
                "domain/entities.py",
                "domain/repositories.py",
                "application/use_cases.py",
                "adapters/controllers.py",
                "adapters/repositories.py",
                "frameworks/fastapi_app.py",
            ],
            "mvc": [
                "models/user.py",
                "models/product.py",
                "views/user_view.py",
                "controllers/user_controller.py",
                "config/settings.py",
            ],
            "layered": [
                "presentation/views.py",
                "business/services.py",
                "persistence/repositories.py",
                "common/utils.py",
            ],
            "microservices": [
                "auth_service/routes.py",
                "data_service/routes.py",
                "api_gateway/gateway.py",
                "shared/models.py",
            ],
        }
        return architectures.get(self.current_config.architecture, [])


# ============================================================================
# SINGLETON PATTERN - Global Orchestrator Instance
# ============================================================================

_orchestrator_instance: Optional[RalphOrchestrator] = None


def get_orchestrator(workspace_dir: Optional[Path] = None) -> RalphOrchestrator:
    """
    Get or create global orchestrator instance.

    Usage from UI:
        from orchestrator import get_orchestrator
        orchestrator = get_orchestrator()
        result = orchestrator.create_project(config)
    """
    global _orchestrator_instance
    if _orchestrator_instance is None:
        _orchestrator_instance = RalphOrchestrator(workspace_dir)
    return _orchestrator_instance


# ============================================================================
# FOR TESTING / CLI
# ============================================================================

if __name__ == "__main__":
    logger.info("Testing orchestrator...")

    orchestrator = get_orchestrator()

    # Test: Create project
    config = ProjectConfig(
        name="Test AI API",
        domain="llm-app",
        architecture="clean_architecture",
        framework="FastAPI",
        database="PostgreSQL",
    )

    result = orchestrator.create_project(config)
    logger.info(f"Create result: {json.dumps(result, indent=2, default=str)}")

    # Test: List projects
    projects = orchestrator.list_projects()
    logger.info(f"Found projects: {len(projects)}")
    for p in projects:
        logger.info(f"  - {p['name']} ({p['domain']})")